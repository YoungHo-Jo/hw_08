/*
 * main.c
 *
 *  Created on: 2017. 11. 27.
 *      Author: hw_8
 */
/*
#include "init.h"
#include "touchSensor.h"
#include "lcd.h"
#include "Touch.h"


int main() {
	// set system and set clock
	defaultSystemInit();

	LCD_Init();
	Touch_Configuration();
	LCD_Clear(WHITE);
	GPIO_touch_init_all();
	init_Timer2();

	while (1) {

	}
}
*/
#include "stm32f10x_rcc.h"
#include "stm32f10x_gpio.h"
#include "stm32f10x_usart.h"
#include "stm32f10x_exti.h"
#include "stm32f10x_adc.h"
#include "stm32f10x_dac.h"
#include "stm32f10x_tim.h"
#include "stm32f10x_dma.h"
#include "misc.h"
#include "lcd.h"
#include "Touch.h"

void SysInit();
void SetSysClock();
void RCC_Init();
void EXTI0_IRQHandler();
void GPIO_button_Init(uint16_t pin, uint8_t pin_src, uint32_t exti_line, uint8_t exti_irqn);
void GPIO_Input_Init();
void GPIO_Output_Init();
void TIM2_IRQHandler();
void init_Timer2();

int syllable;
vu16 tmpValue;
int color[12] = { WHITE, CYAN, BLUE, RED, MAGENTA, LGRAY, GREEN, YELLOW, BROWN,
		BRRED, GRAY };

int main() {
	SysInit();
	SetSysClock();
	syllable = 0;
	RCC_Init();

	LCD_Init();
	Touch_Configuration();
	LCD_Clear(WHITE);


	GPIO_Output_Init();
	GPIO_Input_Init();
	init_Timer2();
	while (1) {

	}
}

void RCC_Init() {
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOD | RCC_APB2Periph_AFIO, ENABLE); // 클럭수를 배당
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);  //클럭 할당
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
}

void EXTI0_IRQHandler()
{
	if (EXTI_GetITStatus(EXTI_Line0) != RESET) {
		syllable ^= 0x01;
		EXTI_ClearITPendingBit(EXTI_Line0);
	}
}
void EXTI3_IRQHandler()
{
	if (EXTI_GetITStatus(EXTI_Line3) != RESET) {
		syllable ^= 0x10;
		EXTI_ClearITPendingBit(EXTI_Line3);
	}
}
void TIM2_IRQHandler(void) //핸들러 함수에서  TIM_GetITStatus(TIM2,TIM_IT_Update)를 통해서 인터럽트 플래그가  set 되어있는지 확인하고 내가 만든 변수 증가한다.
{
	if (TIM_GetITStatus(TIM2, TIM_IT_Update) != RESET) {
		LCD_ShowNum(100, 200, syllable, 5, WHITE, BLUE);
		TIM_ClearITPendingBit(TIM2, TIM_IT_Update); // Clear the interrupt flag
	}
}
void GPIO_button_Init(uint16_t pin, uint8_t pin_src, uint32_t exti_line, uint8_t exti_irqn)
{
	GPIO_InitTypeDef GPIO_InitStructure;
	EXTI_InitTypeDef EXTI_InitStructure;
	NVIC_InitTypeDef NVIC_InitStructure;

	GPIO_InitStructure.GPIO_Pin = pin; // do
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;
	GPIO_Init(GPIOA, &GPIO_InitStructure);
	GPIO_EXTILineConfig(GPIO_PortSourceGPIOA, pin_src);

	EXTI_InitStructure.EXTI_Line = exti_line;
	EXTI_InitStructure.EXTI_LineCmd = ENABLE;
	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising_Falling;
	EXTI_Init(&EXTI_InitStructure);

	NVIC_InitStructure.NVIC_IRQChannel = exti_irqn;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x00;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x00;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);
}

void GPIO_Input_Init() {
	GPIO_button_Init(GPIO_Pin_0, GPIO_PinSource0, EXTI_Line0, EXTI0_IRQn);
	GPIO_button_Init(GPIO_Pin_3, GPIO_PinSource3, EXTI_Line3, EXTI3_IRQn);
}


void SysInit() {
	/* Set HSION bit */
	/* Internal Clock Enable */
	RCC->CR |= (uint32_t) 0x00000001;
	/* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
	RCC->CFGR &= (uint32_t) 0xF0FF0000;

	/* Reset HSEON, CSSON and PLLON bits */
	RCC->CR &= (uint32_t) 0xFEF6FFFF;

	/* Reset HSEBYP bit */
	RCC->CR &= (uint32_t) 0xFFFBFFFF;

	/* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
	RCC->CFGR &= (uint32_t) 0xFF80FFFF;

	/* Reset PLL2ON and PLL3ON bits */
	RCC->CR &= (uint32_t) 0xEBFFFFFF;

	/* Disable all interrupts and clear pending bits  */
	RCC->CIR = 0x00FF0000;

	/* Reset CFGR2 register */
	RCC->CFGR2 = 0x00000000;
}

void SetSysClock(void) {
	volatile uint32_t StartUpCounter = 0, HSEStatus = 0;

	/* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/
	/* Enable HSE */
	RCC->CR |= ((uint32_t) RCC_CR_HSEON);

	/* Wait till HSE is ready and if Time out is reached exit */
	do {
		HSEStatus = RCC->CR & RCC_CR_HSERDY;
		StartUpCounter++;
	} while ((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));

	if ((RCC->CR & RCC_CR_HSERDY) != RESET) {
		HSEStatus = (uint32_t) 0x01;
	} else {
		HSEStatus = (uint32_t) 0x00;
	}

	if (HSEStatus == (uint32_t) 0x01) {
		/* Enable Prefetch Buffer */
		FLASH->ACR |= FLASH_ACR_PRFTBE;

		/* Flash 0 wait state */
		//Flash LATENCY를 조절하는부분 -> FLASH_ACR부분에서 flash와 System Clock의 속도를 맞춰주는 역할!
		//수정할 필요없음
		FLASH->ACR &= (uint32_t) ((uint32_t) ~FLASH_ACR_LATENCY);
		FLASH->ACR |= (uint32_t) FLASH_ACR_LATENCY_1;

		/* HCLK = SYSCLK */
		//현재 SystemClock과 HCLK, PCLK1,PCLK2은 같은 상태(/1)
		//=> 우리가 만들려는 상태로!
		RCC->CFGR |= (uint32_t) RCC_CFGR_HPRE_DIV2;

		/* PCLK2 = HCLK */
		RCC->CFGR |= (uint32_t) RCC_CFGR_PPRE2_DIV2;

		/* PCLK1 = HCLK */
		RCC->CFGR |= (uint32_t) RCC_CFGR_PPRE1_DIV1;

		/* Configure PLLs ------------------------------------------------------*/
		/* PLL configuration: PLLCLK = ???? */
		//앞 clock tree에서 PREDIV1SCH를 거쳐 PREDIV1과 PLLMUL를 조정해서 System clock을 40으로!
		//이미 CFGR2에서 조절한 값을 이용하여 조절!!
		RCC->CFGR &= (uint32_t) ~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC
				| RCC_CFGR_PLLMULL);
		RCC->CFGR |= (uint32_t) (RCC_CFGR_PLLXTPRE_PREDIV1
				| RCC_CFGR_PLLSRC_PREDIV1 |
				RCC_CFGR_PLLMULL5);

		/* PLL2 configuration: PLL2CLK = ???? */
		/* PREDIV1 configuration: PREDIV1CLK = ???? */
		//HSE에서 들어오는 frequency = 25MHz
		//HSE -> CFGR2 -> CFGR1 -> System순일떄 PREDIV2와 PLL2MUL를 잘 조절해서 CFGR1으로!
		RCC->CFGR2 &= (uint32_t) ~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL |
		RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC);
		RCC->CFGR2 |= (uint32_t) (RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 |
		RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV5);

		/* Enable PLL2 */
		RCC->CR |= RCC_CR_PLL2ON;
		/* Wait till PLL2 is ready */
		while ((RCC->CR & RCC_CR_PLL2RDY) == 0) {
		}

		/* Enable PLL */
		RCC->CR |= RCC_CR_PLLON;

		/* Wait till PLL is ready */
		while ((RCC->CR & RCC_CR_PLLRDY) == 0) {
		}

		/* Select PLL as system clock source */
		RCC->CFGR &= (uint32_t) ((uint32_t) ~(RCC_CFGR_SW));
		RCC->CFGR |= (uint32_t) RCC_CFGR_SW_PLL;

		/* Wait till PLL is used as system clock source */
		while ((RCC->CFGR & (uint32_t) RCC_CFGR_SWS) != (uint32_t) 0x08) {
		}
	} else { /* If HSE fails to start-up, the application will have wrong clock
	 configuration. User can add here some code to deal with this error */
	}

	RCC->APB2ENR |= RCC_APB2ENR_IOPAEN | RCC_APB2ENR_IOPDEN; // enable PORT_D PORT_A

	GPIOD->CRL = GPIO_CRL_MODE2_0; // set PD2 to MODE2 // output
	GPIOD->CRL = GPIO_CRL_MODE2_0; // set PD2 to MODE2 // output

	GPIOA->CRH = GPIO_CRH_CNF8_1 | GPIO_CRH_MODE8;
	RCC->CFGR |= RCC_CFGR_MCO_SYSCLK;
}

void init_Timer2() {
	NVIC_InitTypeDef NVIC_InitStructure;
	TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;

	/* TIM2 Clock Enable */

	/* Enable TIM2 Global Interrupt */
	NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);  //NVIC 초기화

	/* TIM2 Initialize */
	TIM_TimeBaseStructure.TIM_Period = 200 - 1; // 100kHz// 주기
	TIM_TimeBaseStructure.TIM_Prescaler = 1000 - 1; //
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure); //타임 초기화

	/* TIM2 Enale */
	TIM_Cmd(TIM2, ENABLE); //타이머가 가득차면 인터럽트 발생
	TIM_ITConfig(TIM2, TIM_IT_Update | TIM_IT_CC1, ENABLE); // interrupt enable
}
