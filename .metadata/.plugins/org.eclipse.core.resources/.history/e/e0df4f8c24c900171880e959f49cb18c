#include "stm32f10x.h"
#include "stm32f10x_gpio.h"
#include "stm32f10x_rcc.h" // apb2를 제어하기 위함...
#include "stm32f10x_tim.h" // timer을 제어하기 위한 함수가 모여잇음
#include "stm32f10x_adc.h"
#include "stm32f10x_dma.h"
#include "misc.h"
#include "lcd.h"
int time = 0;
int ADC_Update = 0;
vu16 ADC_Value[1];

//ADC 설정 : 조도센서 값 출력 Channel 8번 사용.
void ADC1_Configuration(void) {
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);

    ADC_InitTypeDef ADC_InitStructure;

    /* ADC1 configuration ------------------------------------------------------*/

    ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;

    ADC_InitStructure.ADC_ScanConvMode = ENABLE;

    ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;

    ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;

    ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;

    ADC_InitStructure.ADC_NbrOfChannel = 1;

    ADC_Init(ADC1, & ADC_InitStructure);

    /* ADC1 regular channel8 configuration */

    ADC_RegularChannelConfig(ADC1, ADC_Channel_8, 1, ADC_SampleTime_55Cycles5);

    /* Enable ADC1 DMA */

    ADC_DMACmd(ADC1, ENABLE);



    /* Enable ADC1 */

    ADC_Cmd(ADC1, ENABLE);

    /* Enable ADC1 EOC interupt */
    ADC_ITConfig(ADC1, ADC_IT_EOC, ENABLE);


    /* Enable ADC1 reset calibaration register */

    ADC_ResetCalibration(ADC1);

    /* Check the end of ADC1 reset calibration register */

    while (ADC_GetResetCalibrationStatus(ADC1));



    /* Start ADC1 calibaration */

    ADC_StartCalibration(ADC1);

    /* Check the end of ADC1 calibration */

    while (ADC_GetCalibrationStatus(ADC1));



    /* Start ADC1 Software Conversion */

    ADC_SoftwareStartConvCmd(ADC1, ENABLE);

}


void GPIO_Configuration(void) {
    GPIO_InitTypeDef GPIO_InitStructure;
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);

    //PB0 조도센서
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
    GPIO_Init(GPIOB, & GPIO_InitStructure);

}

void init_Timer() {
    NVIC_InitTypeDef NVIC_InitStructure; // for interreupt
    TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure; // timerbase...

    /* TIM2 Clock Enable */
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);

    /* Enable TIM2 Global Interrupt */
    NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Init( & NVIC_InitStructure);

    /* TIM2 Initialize */
    TIM_TimeBaseStructure.TIM_Period = 2000;
    TIM_TimeBaseStructure.TIM_Prescaler = 35999;
    //계산방법 : HZ 는 Prescaler가 1이 아니므로 72MHz이다 따라서 1/72MHz * 2000 * 36000 = 1초
    TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;
    TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
    TIM_TimeBaseInit(TIM2, & TIM_TimeBaseStructure);

    /* TIM2 Enale */
    TIM_ARRPreloadConfig(TIM2, ENABLE);
    TIM_Cmd(TIM2, ENABLE);
    TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE); // interrupt enable

}

void DMA_Configuration() {
    DMA_InitTypeDef DMA_InitStructure;
    /* Enable DMA1 clock */
    RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);

    /* DMA1 channel1 configuration ----------------------------------------------*/

    DMA_DeInit(DMA1_Channel1);

    DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t) &ADC1->DR;

    DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t) ADC_Value;

    DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;

    DMA_InitStructure.DMA_BufferSize = 1;

    DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;

    DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Disable;

    DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;

    DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;

    DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;

    DMA_InitStructure.DMA_Priority = DMA_Priority_High;

    DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;

    DMA_Init(DMA1_Channel1, & DMA_InitStructure);

    /* Enable DMA1 channel1 */

    DMA_Cmd(DMA1_Channel1, ENABLE);
}

//TIM2
void TIM2_IRQHandler(void) {
    //초를 계산
    time++;
    // LED 출력 //
    ADC_Update = (int)ADC_Value[0];
    TIM_ClearITPendingBit(TIM2, TIM_IT_Update);
    //Clears the TIMx's interrupt pending bits.
}

int main() {
    SystemInit();
    GPIO_Configuration();
    LCD_Init();
    LCD_Clear(WHITE);
    ADC1_Configuration();
    DMA_Configuration();
    init_Timer();
    while (1) {
        LCD_ShowNum(60, 60, time, 20, BLACK, WHITE);
        LCD_ShowNum(60, 100, ADC_Update, 20, BLACK, WHITE);
    }
}
