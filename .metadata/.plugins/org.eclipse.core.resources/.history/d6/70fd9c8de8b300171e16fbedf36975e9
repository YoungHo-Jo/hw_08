#include "stm32f10x.h"
#include "stm32f10x_rcc.h"
#include "stm32f10x_gpio.h"
#include "stm32f10x_usart.h"
#include "stm32f10x_exti.h"
#include "misc.h"
#include "core_cm3.h"

void SysInit(void) {
	/* Set HSION bit */
	/* Internal Clock Enable */
	RCC->CR |= (uint32_t) 0x00000001;


	/* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
	RCC->CFGR &= (uint32_t) 0xF0FF0000;

	/* Reset HSEON, CSSON and PLLON bits */
	RCC->CR &= (uint32_t) 0xFEF6FFFF;

	/* Reset HSEBYP bit */
	RCC->CR &= (uint32_t) 0xFFFBFFFF;

	/* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
	RCC->CFGR &= (uint32_t) 0xFF80FFFF;

	/* Reset PLL2ON and PLL3ON bits */
	RCC->CR &= (uint32_t) 0xEBFFFFFF;

	/* Disable all interrupts and clear pending bits  */
	RCC->CIR = 0x00FF0000;

	/* Reset CFGR2 register */
	RCC->CFGR2 = 0x00000000;
}

void SetSysClock(void)
{
	volatile uint32_t StartUpCounter = 0, HSEStatus = 0;

  /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/
  /* Enable HSE */
  RCC->CR |= ((uint32_t)RCC_CR_HSEON);

  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC->CR & RCC_CR_HSERDY;
    StartUpCounter++;
  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));

  if ((RCC->CR & RCC_CR_HSERDY) != RESET)
  {
    HSEStatus = (uint32_t)0x01;
  }
  else
  {
    HSEStatus = (uint32_t)0x00;
  }

  if (HSEStatus == (uint32_t)0x01)
  {
    /* Enable Prefetch Buffer */
    FLASH->ACR |= FLASH_ACR_PRFTBE;

    /* Flash 0 wait state */
    FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
    FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_0;

    /* HCLK = SYSCLK */
    RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;

    /* PCLK2 = HCLK */
    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV2;

    /* PCLK1 = HCLK */
    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV1;

    /* Configure PLLs ------------------------------------------------------*/
    /* PLL configuration: PLLCLK = ???? */
    RCC->CFGR &= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);
    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 |
                            RCC_CFGR_PLLMULL4);

    /* PLL2 configuration: PLL2CLK = ???? */
    /* PREDIV1 configuration: PREDIV1CLK = ???? */
    RCC->CFGR2 &= (uint32_t)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL |
                              RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC);
    RCC->CFGR2 |= (uint32_t)(RCC_CFGR2_PREDIV2_DIV8 | RCC_CFGR2_PLL2MUL8 |
                             RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV5);

    /* Enable PLL2 */
    RCC->CR |= RCC_CR_PLL2ON;
    /* Wait till PLL2 is ready */
    while((RCC->CR & RCC_CR_PLL2RDY) == 0)
    {
    }

    /* Enable PLL */
    RCC->CR |= RCC_CR_PLLON;

    /* Wait till PLL is ready */
    while((RCC->CR & RCC_CR_PLLRDY) == 0)
    {
    }

    /* Select PLL as system clock source */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
    RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;

    RCC->CFGR &= (uint32_t)~(RCC_CFGR_MCO);
    RCC->CFGR |= (uint32_t)RCC_CFGR_MCO_SYSCLK;

    /* Wait till PLL is used as system clock source */
    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)
    {
    }
  }
  else
  { /* If HSE fails to start-up, the application will have wrong clock
         configuration. User can add here some code to deal with this error */
  }
}

void delay(int i) {
   int k = 0;
   for(k = 0; k < i; k++);
}

void RCC_Configuration(void) {

   RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD, ENABLE); // Button, LED
   RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); // USART1_TX와 RX
   RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);  // EXTI를 이용하기 위해서는 AFIO 블럭 ENABLE 시켜줘야함.
   RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE); //USART1

}

void GPIO_Configuration() {

   GPIO_InitTypeDef GPIO_InitStructure;

    // USART1 TX Init
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9 ;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP ;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz ;
    GPIO_Init(GPIOA, &GPIO_InitStructure) ;



    // USART RX2 Init
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10 ;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING ;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz ;
    GPIO_Init(GPIOA, &GPIO_InitStructure) ;

    // USART1 TX Init
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP ;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz ;
    GPIO_Init(GPIOA, &GPIO_InitStructure) ;



    // USART RX2 Init
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3 ;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING ;
    //GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz ;
    GPIO_Init(GPIOA, &GPIO_InitStructure) ;
}


void USART_Configuration(void) {

   USART_InitTypeDef USART_InitStructure ;


   USART_InitStructure.USART_BaudRate = 115200;
   USART_InitStructure.USART_WordLength = USART_WordLength_9b ;
   USART_InitStructure.USART_StopBits = USART_StopBits_1 ;
   USART_InitStructure.USART_Parity = USART_Parity_Even ;
   USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None ;
   USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx ;
   USART_Init(USART1, &USART_InitStructure) ;

   USART_Cmd(USART1, ENABLE) ; // usart enable

   USART_ITConfig(USART1, USART_IT_RXNE, ENABLE) ;
   USART_ITConfig(USART1, USART_IT_TXE, ENABLE) ;


}

void EXTI_Configuration(void) { // 버튼 입력시 인터럽트 발생

   EXTI_InitTypeDef EXTI_InitStructure;



   /* GPIO Pin Selection */
   GPIO_EXTILineConfig(GPIO_PortSourceGPIOD, GPIO_PinSource11); // EXTI의 11번의 port d연결
   GPIO_EXTILineConfig(GPIO_PortSourceGPIOD, GPIO_PinSource12); // EXTI의 12번의 port d연결


   /* Button EXTI Selection */
   EXTI_InitStructure.EXTI_Line = EXTI_Line11 | EXTI_Line12; // Specifies the EXTI Lines to be enabled or disabled.
   EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt; // EXTI_IMR 에 값 설정
   EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
   EXTI_InitStructure.EXTI_LineCmd = ENABLE; // Specifies the new state of the selected EXTI lines.
   EXTI_Init(&EXTI_InitStructure);

}


void NVIC_Configuration(void) {

   NVIC_InitTypeDef NVIC_InitStructure ;


   NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn ;
   NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x00 ;
   NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x00 ;
   NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE ;
   NVIC_Init(&NVIC_InitStructure) ;

   NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn ;
   NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x00 ;
   NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x00 ;
   NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE ;
   NVIC_Init(&NVIC_InitStructure) ;




}






void LED_WAVE(void) {

   GPIO_SetBits(GPIOD, GPIO_Pin_2);
   delay(1000000);
   GPIO_ResetBits(GPIOD, GPIO_Pin_2);

   GPIO_SetBits(GPIOD, GPIO_Pin_3);
   delay(1000000);
   GPIO_ResetBits(GPIOD, GPIO_Pin_3);

   GPIO_SetBits(GPIOD, GPIO_Pin_4);
   delay(1000000);
   GPIO_ResetBits(GPIOD, GPIO_Pin_4);

   GPIO_SetBits(GPIOD, GPIO_Pin_7);
   delay(1000000);
   GPIO_ResetBits(GPIOD, GPIO_Pin_7);

}



void send_string(char* str) {

   while(*str != '\0') {
      USART_SendData(USART1, *(unsigned char*)str);
      while(USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);
	  str++;
   }

}



void EXTI15_10_IRQHandler(void) {

   // Button 11

   if (EXTI_GetITStatus(EXTI_Line11) != RESET) {

      LED_WAVE();

      EXTI_ClearITPendingBit(EXTI_Line11);

   }

   // Button 12

   else if (EXTI_GetITStatus(EXTI_Line12) != RESET) {

      send_string("WED team08 UART TEST\0");

      delay(1000000);

      EXTI_ClearITPendingBit(EXTI_Line12);

   }



}








void led_toogle() {

    GPIO_SetBits(GPIOD, GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_7);
    delay(1000000);
    GPIO_ResetBits(GPIOD, GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_7);
    delay(1000000);

}



void USART1_IRQHandler(void) {

   char temp;


   if (USART_GetITStatus(USART1, USART_IT_RXNE) != RESET) {

      temp = (unsigned char)USART_ReceiveData(USART1);

      USART_SendData(USART1, temp);

      led_toogle();
      led_toogle();

      USART_ClearITPendingBit(USART1, USART_IT_RXNE);

      delay(100000);

   }



}






int main() {
      SysInit();
      SetSysClock();

      RCC_Configuration() ;
      GPIO_Configuration() ;
      EXTI_Configuration() ;
      NVIC_Configuration();
      USART_Configuration() ;


      while(1) {
      }

}
